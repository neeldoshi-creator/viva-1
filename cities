# Binary Search Tree Node
class Node:
    def _init_(self, city, population):
        self.city = city
        self.population = population
        self.left = None
        self.right = None

# Insert a new city
def insert(root, city, population):
    if root is None:
        return Node(city, population)
    if city < root.city:
        root.left = insert(root.left, city, population)
    elif city > root.city:
        root.right = insert(root.right, city, population)
    else:
        print("City already exists! Use update option to modify population.")
    return root

# Search city and count comparisons
def search(root, city):
    comparisons = 0
    current = root
    while current:
        comparisons += 1
        if city == current.city:
            print(f"City '{city}' found with population {current.population}")
            print(f"Comparisons made: {comparisons}")
            return current
        elif city < current.city:
            current = current.left
        else:
            current = current.right
    print(f"City '{city}' not found. Comparisons made: {comparisons}")
    return None

# Update population of an existing city
def update(root, city, new_population):
    node = search(root, city)
    if node:
        node.population = new_population
        print(f"Population of '{city}' updated to {new_population}")

# Find minimum node (helper for delete)
def find_min(root):
    while root.left:
        root = root.left
    return root

# Delete a city
def delete(root, city):
    if root is None:
        return root
    if city < root.city:
        root.left = delete(root.left, city)
    elif city > root.city:
        root.right = delete(root.right, city)
    else:
        # Node with one or no child
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        # Node with two children
        temp = find_min(root.right)
        root.city = temp.city
        root.population = temp.population
        root.right = delete(root.right, temp.city)
    return root

# Display cities in ascending order
def inorder(root):
    if root:
        inorder(root.left)
        print(f"{root.city} : {root.population}")
        inorder(root.right)

# Display cities in descending order
def reverse_inorder(root):
    if root:
        reverse_inorder(root.right)
        print(f"{root.city} : {root.population}")
        reverse_inorder(root.left)

# -------------------- MAIN PROGRAM --------------------
root = None

while True:
    print("\n--- City Population Management using BST ---")
    print("1. Add new city")
    print("2. Delete a city")
    print("3. Update population")
    print("4. Display cities in Ascending order")
    print("5. Display cities in Descending order")
    print("6. Search city and show comparisons")
    print("7. Exit")

    ch = int(input("Enter your choice: "))

    match ch:
        case 1:
            city = input("Enter city name: ")
            population = int(input("Enter population: "))
            root = insert(root, city, population)

        case 2:
            city = input("Enter city name to delete: ")
            root = delete(root, city)

        case 3:
            city = input("Enter city name to update: ")
            new_pop = int(input("Enter new population: "))
            update(root, city, new_pop)

        case 4:
            print("\nCities in Ascending order:")
            inorder(root)

        case 5:
            print("\nCities in Descending order:")
            reverse_inorder(root)

        case 6:
            city = input("Enter city name to search: ")
            search(root, city)

        case 7:
            print("Exiting program...")
            break

        case _:
            print("Invalid choice! Try again.")

